@tool
extends RefCounted

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchGetUserEmotesResponse

## 
var data: Array[Data];
## A templated URL. Uses the values from the _id_, _format_, _scale_, and _theme\_mode_ fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote.        For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL](https://dev.twitch.tv/docs/irc/emotes#cdn-template) format.
var template: String;
## Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.        For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
var pagination: Pagination;

static func from_json(d: Dictionary) -> TwitchGetUserEmotesResponse:
	var result = TwitchGetUserEmotesResponse.new();
	if d.has("data") && d["data"] != null:
		for value in d["data"]:
			result.data.append(Data.from_json(value));
	if d.has("template") && d["template"] != null:
		result.template = d["template"];
	if d.has("pagination") && d["pagination"] != null:
		result.pagination = Pagination.from_json(d["pagination"]);
	return result;

func to_dict() -> Dictionary:
	var d: Dictionary = {};
	d["data"] = [];
	if data != null:
		for value in data:
			d["data"].append(value.to_dict());
	d["template"] = template;
	if pagination != null:
		d["pagination"] = pagination.to_dict();
	return d;

func to_json() -> String:
	return JSON.stringify(to_dict());

## 
class Data extends RefCounted:
	## An ID that uniquely identifies this emote.
	var id: String;
	## The User ID of broadcaster whose channel is receiving the unban request.
	var name: String;
	## The type of emote. The possible values are:       * **bitstier** — A Bits tier emote. * **follower** — A follower emote. * **subscriptions** — A subscriber emote.
	var emote_type: String;
	## An ID that identifies the emote set that the emote belongs to.
	var emote_set_id: String;
	## The ID of the broadcaster who owns the emote.
	var owner_id: String;
	## The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.       * **animated** — An animated GIF is available for this emote. * **static** — A static PNG file is available for this emote.
	var format: Array[String];
	## The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.       * **1.0** — A small version (28px x 28px) is available. * **2.0** — A medium version (56px x 56px) is available. * **3.0** — A large version (112px x 112px) is available.
	var scale: Array[String];
	## The background themes that the emote is available in.       * **dark** * **light**
	var theme_mode: Array[String];


	static func from_json(d: Dictionary) -> Data:
		var result = Data.new();
		if d.has("id") && d["id"] != null:
			result.id = d["id"];
		if d.has("name") && d["name"] != null:
			result.name = d["name"];
		if d.has("emote_type") && d["emote_type"] != null:
			result.emote_type = d["emote_type"];
		if d.has("emote_set_id") && d["emote_set_id"] != null:
			result.emote_set_id = d["emote_set_id"];
		if d.has("owner_id") && d["owner_id"] != null:
			result.owner_id = d["owner_id"];
		if d.has("format") && d["format"] != null:
			for value in d["format"]:
				result.format.append(value);
		if d.has("scale") && d["scale"] != null:
			for value in d["scale"]:
				result.scale.append(value);
		if d.has("theme_mode") && d["theme_mode"] != null:
			for value in d["theme_mode"]:
				result.theme_mode.append(value);
		return result;

	func to_dict() -> Dictionary:
		var d: Dictionary = {};
		d["id"] = id;
		d["name"] = name;
		d["emote_type"] = emote_type;
		d["emote_set_id"] = emote_set_id;
		d["owner_id"] = owner_id;
		d["format"] = [];
		if format != null:
			for value in format:
				d["format"].append(value);
		d["scale"] = [];
		if scale != null:
			for value in scale:
				d["scale"].append(value);
		d["theme_mode"] = [];
		if theme_mode != null:
			for value in theme_mode:
				d["theme_mode"].append(value);
		return d;


	func to_json() -> String:
		return JSON.stringify(to_dict());

## Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.        For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
class Pagination extends RefCounted:
	## The cursor used to get the next page of results. Use the cursor to set the request’s after query parameter.
	var cursor: String;


	static func from_json(d: Dictionary) -> Pagination:
		var result = Pagination.new();
		if d.has("cursor") && d["cursor"] != null:
			result.cursor = d["cursor"];
		return result;

	func to_dict() -> Dictionary:
		var d: Dictionary = {};
		d["cursor"] = cursor;
		return d;


	func to_json() -> String:
		return JSON.stringify(to_dict());

